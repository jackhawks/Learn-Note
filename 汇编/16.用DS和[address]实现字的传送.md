# 用DS和[address]实现字的传送



## 要解决的问题：CPU从内存单元中要读取数据



- 要求
  - CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址
- 原理
  - 在8086 PC中，内存地址由段地址和偏移地址组成（段地址：偏移地址）
- 解决方案：DS和`[address]`配合
  - 用DS寄存器存放要访问的数据的段地址
  - 偏移地址用`[]`形式直接给出



>  例子1

```assembly
mov bx,1000H
mov ds,bx
mov al,[0]

; 将 10000H（1000:0）中的数据读到al中
```



>  例子2

```assembly
mov bx,1000H
mov ds,bx
mov [0],al

; 将al中的数据写入到10000H（1000:0）中
```



- 将段地址送入DS的两种方式

  - (1) ~~不行~~

    ```assembly
    mov ds,1000H
    ```

  - (2) **可以**

    ``` assembly
    mov bx,1000H
    mov ds,bx
    ```

- 8086 CPU 不支持将数据直接送入段寄存器（硬件设计问题）
- 套路：数据   ------->  一般寄存器   ------->  段寄存器





## 字的传送



- 8086 CPU 可以一次性传送一个字（16位的数据）

- 例

  - ```assembly
    mov bx,1000H
    mov ds,bx
    mov ax,[0]        ; 1000:0处的字型数据送入ax
    mov [0],cx        ; cx中的16位数据送到1000:0处
    ```



### 案例1



>  内存

| 内存地址 | 数据 |
| :------: | :--: |
|  10000H  |  23  |
|  10001H  |  11  |
|  10002H  |  22  |
|  10003H  |  66  |



> 指令

```assembly
mov ax,1000H
mov ds,ax
mov ax,[0]
mov bx,[2]
mov cx,[1]
add bx,[1]
add cx,[2]
```



> 寄存器

```assembly
AX=1123
BX=8833
CX=8833
DX=1000
```

