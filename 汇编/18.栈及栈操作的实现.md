# 栈及栈操作的实现



## 栈结构



- 栈是一种只能在一端进行插入或删除操作的数据结构
- 栈有两个基本的操作：入栈和出栈
  - 入栈：将一个新的元素放到栈顶
  - 出栈：从栈顶取出一个元素
- 栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出
- 栈的操作规则：LIFO（Last In First Out，后进先出）
- CPU 提供的栈机制
  - 现如今的 CPU 中都有栈的设计
  - 8086 CPU 提供相关的指令，支持用栈的方式访问内存空间
  - 基于 8086 CPU 的编程，可以将一段内存当作栈来使用



```assembly
入栈  出栈
   \ /
   |1|
   |0|
   ---
```



- PUSH（入栈）和 POP（出栈）指令
  - push ax : 将 ax 中的数据送入栈中
  - pop ax : 从栈顶取出数据送入ax
  - **(以字为单位对栈进行操作)**



## 例：设将 10000H~1000FH 内存当作栈来使用



```assembly
mov ax,0123H
push ax
mov bx,2266H
push bx
mov cx,1122H
push cx
pop ax
pop bx
pop cx
```



```assembly
10000H    ---------
          |       |
          |       |
          |       |
          |       |
          |       |   
10009H    |       |   
1000AH    |       |   22
1000BH    |       |   11
1000CH    |       |   66
1000DH    |       |   22
1000EH    |       |   23
1000FH    |_______|   01
```



- 问题：
  1. CPU 是如何知道一段内存空间被当作栈使用？
  2. 执行 push 和 pop 的时候，如何知道哪个单元是栈顶单元？
- 回答：
  - 8086 CPU 中，有两个与栈相关的寄存器：
    - 栈段寄存器 SS：存放栈顶的段地址
    - 栈顶指针寄存器 SP：存放栈顶的便宜地址
  - 任意时刻，SS:SP 指向栈顶元素



## 栈的操作



```assembly
mov ax,1000H
mov ss,ax
mov sp,0010H
```

|  AX   |  BX  |  SS   |  SP  |
| :---: | :--: | :---: | :--: |
| 1000H |      | 1000H | 0010 |



```assembly
mov ax,001AH
mov bx,001BH
```

|  AX   |  BX   |  SS   |  SP  |
| :---: | :---: | :---: | :--: |
| 001AH | 001BH | 1000H | 0010 |



```assembly
push ax
push bx
```

|  AX   |  BX   |  SS   |  SP  |
| :---: | :---: | :---: | :--: |
| 001AH | 001BH | 1000H | 0010 |



```assembly
pop ax
pop bx
```

|  AX   |  BX   |  SS   |  SP  |
| :---: | :---: | :---: | :--: |
| 001BH | 001AH | 1000H | 0010 |





## push 指令和 pop 指令的执行过程



```assembly
mov ax,1000H
mov ss,ax
mov sp,0010H

mov ax,001AH
mov bx,001BH

push ax
push bx

pop ax
pop bx
```



- push ax
  1. SP = SP - 2
  2. 将 ax 中的内容送入 SS:SP 指向的内存单元处， SS:SP 此时指向新的栈顶
- pop ax
  1. 将 SS:SP 指向的内存单元处的数据送入 ax 中
  2. SP = SP + 2 ，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶





## 执行入栈 （push）时，栈顶超出栈空间



- 栈顶超界问题
  - 如何能够保证在入栈、出栈时，栈顶不会超出栈空间？



- 当栈满的时候再使用 push 指令入栈，将发生超界问题
  - 栈顶超界是危险的
- 当栈空的时候再使用 pop 指令出栈，将发生栈顶超界问题
  - 栈顶超界是危险的



## 栈顶超界问题的解决*



- 8086 CPU 不保证对栈的操作不会越界
  - 8086 CPU 只知道栈顶在何处（由 SS:SP 指示），不知道程序安排的栈空间有多大
- 我们在编程的时候要自己操心栈顶越界问题，要根据可能用到的最大栈空间来安排栈的大小，防止栈的数据太多而导致的超界；防止出栈时栈空了仍然继续出栈而导致的超界



## 栈的小结



- push、pop 实质上就是一种内存传送的指令，可以在寄存器和内存直接传送数据，与 mov 指令不同的是，push 和 pop 指令访问的内存单元地址不是在指令中给出的，而是由 SS:SP 指出的。
- 执行 push 和 pop 指令时，SP 中的内容会自动改变。



- 8086 CPU 提供的栈操作机制：

  - 在 SS，SP 中存放栈顶的段地址和偏移地址，入栈和出栈指令根据 SS:SP 指示的地址，按照栈的方式访问内存单元。

  - push 指令的执行步骤：
    1. SP = SP - 2
    2. 向 SS:SP 指向的字单元中送入数据。
  - pop 指令执行的步骤：
    1. 从 SS:SP 指向的字单元中读取数据
    2. SP = SP + 2