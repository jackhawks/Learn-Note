# 二进制数据序列化

MTProto操作要求基本和复合数据类型以及将这些数据类型作为参数传递或返回的查询，都以二进制格式（即序列化）进行传输。[TL语言](https://core.telegram.org/mtproto/TL)用于描述要序列化的数据类型。

### 一般定义

出于我们的目的，我们可以将类型识别为其（序列化的）值的集合，这些值被理解为32位数字的字符串（有限序列）（以小端序传输）。

因此：

-   字母表（A）在这种情况下是一组32位数字（通常是有符号的，即介于 -2^31 和 2^31 - 1 之间）。
-   在这种情况下，Value 与 Alphabet A 中的字符串相同，即一组有限的（可能为空的）32位数字序列。所有这些序列的集合被指定为 A*。
-   就我们的目的而言， Type 与 Type 的合法值集合相同，即某个集合 T 是 A* 的子集，并且是一个前缀码（即 T 中的任何元素都不能是任何其他元素的前缀） 。因此，A* 中的任何序列只能包含一个属于 T 成员的前缀。
-   Type T 的值是任何作为 A* 子集中 T 的成员的序列（值）。
-   兼容类型是作为 A* 子集不相交的类型 T 和 T'，使得 T 和 T' 的并集是一个前缀码。 
-   *类型协调系统*是类型 T_1, ..., T_n, ... 的一组有限或无限集合，使得该集合中的任何两种类型都是兼容的。
-   数据类型与上述定义中的类型相同。 
-   函数类型是描述函数的类型；它不是上述定义意义上的类型。最初，我们忽略函数类型的存在，只描述数据类型；然而，在实际中，函数类型将在使用所谓的临时组合器的系统扩展中实现。

#### 组合器、构造器、复合数据类型

-   组合器是一种函数，它接受特定类型的参数并返回某些其他类型的值。我们通常会考虑参数和结果类型是数据类型（而不是函数类型）的组合器。

-   组合器的元数是一个非负整数，表示组合器参数的数量。
-   *组合器标识符*是以小写罗马字母开头的标识符，它唯一地标识一个组合器。
-   组合器编号或组合器名称是唯一标识组合器的 32 位数字（即A的一个元素）。最常见的是组合器描述字符串的 CRC32 值，该字符串不包括最后的分号，并且相邻词位之间只有一个空格。它始终落在 0x01000000 到 0xffffff00 的范围内。最高 256 个值保留给用于传输函数的所谓*时间逻辑组合器*。我们通常用单引号表示组合器名称：'combinator'。

-   组合器描述是一个格式为 `combinator_name type_arg_1 ... type_arg_N = type_res;` 的字符串，其中 `N` 代表组合器的元数，`type_arg_i` 是第 i 个参数的类型（或者更确切地说，具有组合器名称的字符串），并且 `type_res` 是组合器值类型。

-   构造器是一个无法被计算（简化）的组合器。这用于表示复合数据类型。例如，组合器 “int_tree” 的描述为 `int_tree IntTree int IntTree = IntTree` ，连同组合器 `empty_tree = IntTree` 一起，可用于定义一个称为 “IntTree” 的复合数据类型，该数据类型采用以整数作为节点的二叉树形式的值。

-   函数（功能组合器）是一个可以在提供了所需数量和类型的参数的条件下被计算（简化）的组合器。计算的结果是只包含构造器和基本类型值的表达式。

-   *正常形式*是一个仅包含构造器和基本类型值的表达式；通常是计算函数的结果。

-   *类型标识符*是通常以罗马字母大写字母开头的标识符，唯一地标识一个类型。

-   *类型编号*或*类型名称*是唯一标识类型的 32 位数字；它通常是该类型构造函数描述的 CRC32 值的之和。

-   *（复合）类型 T 的描述*是所有取值为类型 T 的构造器的描述的集合。这通常以文本形式书写，每个字符串包含一个单独构造器的描述。例如，类型 “IntTree” 的描述如下：

    int_tree IntTree int IntTree = IntTree; empty_tree = IntTree;

-   多态类型是其描述中包含参数（类型变量）代替实际类型的类型；大致相当于C++中的模板。这里是一个类型 `List alpha` 的描述，其中 `List` 是一个依赖单个参数的多态类型（即，元数为1），并且 `alpha` 是作为构造器的可选参数（在花括号中）出现的类型变量：

    cons {alpha:Type} alpha (List alpha) = List alpha; nil {alpha:Type} = List alpha;

-   *（复合）类型 T 的值*是来自 A* 的任何序列，格式为 `constr_num arg1 ... argN`，其中 constr_num 是某个构造器 C 的索引号，C 取值为类型 T，arg_i 是类型T_i 的值，T_i 是构造器 C 的第 i 个参数的类型。例如，让组合器 int_tree 的索引号为 17，而组合器 empty_tree 的索引号为 239。那么，类型 `IntTree` 的一个值是，例如，`17 17 239 1 239 2 239`，更便于书写为 `'int_tree' 'int_tree' 'empty_tree' 1 'empty_tree' 2 'empty_tree'`。从高级语言的角度看，这是 `int_tree (int_tree (empty_tree) 1 (empty_tree)) 2 (empty_tree): IntTree`。

-   *模式*是所有（复合）数据类型描述的集合。这用于定义一些经过商定的类型系统。

#### 装箱和裸装类型

-   *装箱类型*是一种其任何值都以构造函数编号开始的类型。由于每个构造器都有一个唯一确定的值类型，因此任何装箱类型值中的第一个数字唯一地定义了其类型。这保证了各种装箱类型总体上构成了一个协调的类型系统。装箱类型标识符总是以大写字母开头。

-   裸类型是一种其值不包含构造函数编号的类型，构造函数编号是隐含的。裸类型标识符总是与隐含的构造函数名称一致（因此，以小写字母开头），并且可能在前面加上百分号（%）填充。此外，如果 `X` 是一个最多只有一个构造函数的装箱类型，那么 `%X` 指的是相应的裸类型。裸类型的值与通过从相应装箱类型的值集合中删除第一个数字（即，外部构造器索引号）获得的数字序列集合相同（这是所选构造函数的结果类型），从所选构造函数索引号开始。例如，`3 4` 是由 `int_couple int int = IntCouple` 定义的 `int_couple` 裸类型的一个值。对应的装箱类型是 `IntCouple`；如果 404 是 `int_couple` 的构造器索引号，那么 `404 3 4` 是对应于裸类型 `int_couple`（也被称为 `%int_couple` 和 `%IntCouple`；后者形式在概念上更可取但更长）的 `IntCouple` 装箱类型的值。

从概念上讲，只有装箱类型才应该在任何地方使用。然而，为了速度和紧凑性，必须使用裸类型（例如，10,000 个裸 int 值的数组长度为 40,000 字节，而装箱的 Int 值需要占用两倍的空间；因此，当传输一个大型整数标识符数组时，使用 `Vector int` 类型比使用 `Vector Int` 更高效）。此外，所有基本类型（int、long、double、string）都是裸类型。

如果一个装箱类型是多态的，类型的数量级为 r，那么任何派生的裸类型也是如此。换句话说，如果有人定义了 `intCouple {alpha:Type} int alpha = IntCouple alpha`，那么之后，intCouple 作为标识符也会是一个多态类型，其数量级为 1，在组合器（以及构造函数和类型）描述中也是如此。符号 `intCouple X`、`%(IntCouple X)` 和 `%IntCouple X` 是等价的。

#### 基本类型

基本类型既有裸类型（int、long、double、string）也有装箱类型（Int、Long、Double、String）。它们的构造函数标识符与相应的裸类型名称一致。它们的伪描述如下所示：

```
int ? = Int;
long ? = Long;
double ? = Double;
string ? = String;
```

因此，`int` 构造函数索引号是字符串 `"int ? = Int"` 的 CRC32。

纯类型 `int` 的值正好是所有单元素序列，即在这种情况下，-2^31 和 2^31-1 之间的数字表示它们自己。`long` 类型的值是两个元素的序列，这些序列是 64 位有符号数字（小端模式）。`double` 类型的值同样是两个元素的序列，包含 64 位的实数，采用标准双精度格式。最后，`string` 类型的值看起来有所不同，具体取决于被序列化字符串的长度 L：

-   如果 L <= 253，序列化包含一个字节的 L 值，然后是 L 字节的字符串，后跟 0 到 3 个包含 0 的字符，使得该值的总长度可以被 4 整除，因此所有这些都是解释为 int(L/4)+1 32 位数字的序列。
-   如果 L >= 254，则序列化包含字节 254，后跟 3 个字节的字符串长度 L，然后是 L 字节的字符串，再后跟 0 到 3 个空填充字节。

#### 对象伪类型

伪类型 `Object` 是一种 “类型”，它可以取属于模式中任何装箱类型的值。*这有助于快速定义随机项列表*等之类的类型，而无需使用多态类型。最好不要滥用此功能，因为它会导致动态类型的使用。尽管如此，如果不使用 Object 伪类型，很难想象我们从 PHP 和 JSON 中了解到的数据结构。

建议尽可能使用 `TypedObject` 代替：

```
object X:Type value:X = TypedObject;
```

#### 内置复合类型：向量和关联数组

Vector t 多态伪类型是一种“类型”，其值是任何类型 t 的值序列，无论是装箱的还是裸的。

```
vector {t:Type} # [ t ] = Vector t;
```

序列化始终使用相同的构造函数 “vector” (const 0x1cb5c415 = crc32("vector t:Type # [ t ] = Vector t”)，该构造函数不依赖于类型 t 变量的具体值。Vector t 类型的值 type 是相关构造函数编号的索引号，后面跟着 N（向量中的元素数量），然后是 N 个类型 t 的值。可选参数 t 的值不参与序列化，因为它是从结果类型（始终在反序列化之前已知）中派生的。

多态伪类型 IntHash t 和 StrHash t 是将整数和字符串键映射到类型 t 的值的关联数组。事实上，它们是包含裸二元组 (int, t) 或 (string, t) 的向量：

```
coupleInt {t:Type} int t = CoupleInt t;
intHash {t:Type} (vector %(CoupleInt t)) = IntHash t;
coupleStr {t:Type} string t = CoupleStr t;
strHash {t:Type} (vector %(CoupleStr t)) = StrHash t;
```

在这种情况下，百分号表示采用与括号中的装箱类型相对应的裸类型；无论参数的值是什么，所讨论的装箱类型都不能超过一个构造函数。

键可以排序或采用其他顺序（如同 PHP 数组）。对于具有排序键的关联数组，使用 IntSortedHash 或 StrSortedHash 别名：

```
intSortedHash {t:Type} (intHash t) = IntSortedHash t;
strSortedHash {t:Type} (strHash t) = StrSortedHash t;
```

#### 多态类型构造函数

多态类型的构造函数不依赖于应用多态类型的具体类型。当它被计算时，可选参数（通常包含类型变量并放置在花括号中）不再是可选的（花括号被删除），除此之外，所有括号也被删除。因此，

```
vector {t:Type} # [ t ] = Vector t;
```

对应于构造函数编号 crc32("vector t:Type #[ t ] = Vector t") = 0x1cb5c415。在（反）序列化期间，可选变量 t 的具体值是从始终已知的结果类型（即正在序列化或反序列化的对象）派生的，并且从不显式序列化。

以前，必须知道每个多态类型将应用于哪些具体的变量类型。为了实现这一点，类型系统使用以下形式的字符串

```
polymorphic_type_name type_1 ... type_N;
```

例如，

```
Vector int;
Vector string;
Vector Object;
```

现在它们被忽略了。

另请参见[TL 中的多态性](https://core.telegram.org/mtproto/TL-polymorph)。

在这种情况下，Object 伪类型允许使用 Vector Object 来存储任何内容的列表（任何装箱类型的值）。由于裸类型在短时效率高，因此实际上不太可能需要比上述更复杂的情况。

#### 字段名称

假设我们需要表示用户，作为包含一个整数（用户ID）和两个字符串（名和姓）的三元组。所需的数据结构是三元组 int、string、string，可以声明如下：

```
user int string string = User;
```

另一方面，一个群组可以通过一个类似的三元组来描述，该三元组包括一个群组ID、组名称和描述：

```
group int string string = Group;
```

为了清楚地区分用户和群组，最好为部分或全部字段赋予名称：

```
user id:int first_name:string last_name:string = User;
group id:int title:string description:string = Group;
```

如果将来需要通过在记录中添加一些额外字段来扩展用户类型，可以按照以下方式实现：

```
userv2 id:int unread_messages:int first_name:string last_name:string in_groups:vector int = User;
```

除其他事项外，这种方法有助于定义属于同一类型不同构造器的字段之间的正确映射，来实现它们之间的转换，以及将类型值转换为带有字符串键的关联数组（如果定义了字段名称，那么这些名称是这些键的自然选择）。

### TL语言

参见[TL 语言](https://core.telegram.org/mtproto/TL)