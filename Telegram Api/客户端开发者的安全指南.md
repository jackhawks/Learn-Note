# 客户端开发者的安全指南

**另请参阅：**

-   [完美的前向保密](https://core.telegram.org/api/pfs)
-   [私密聊天、端到端加密](https://core.telegram.org/api/end-to-end)
-   [私密聊天中的完美前向保密](https://core.telegram.org/api/end-to-end/pfs)
-   [MTProto 2.0，详细说明](https://core.telegram.org/mtproto/description)

虽然 [MTProto](https://core.telegram.org/mtproto) 旨在被设计成一个相对快速和安全的协议，但如果实现不当，其优势很容易被抵消。我们在此页面上为客户端软件开发人员收集了一些安全指南。所有 Telegram 客户都必须遵守。

>   请注意，从版本 4.6 开始，主要的 Telegram 客户端都使用 **MTProto 2.0**。MTProto v.1.0 已被弃用，目前正在逐步淘汰。

### Diffie-Hellman 密钥交换

我们在两种情况下使用 DH 密钥交换：

-   [创建授权密钥](https://core.telegram.org/mtproto/auth_key)
-   [建立端到端加密的私密聊天](https://core.telegram.org/api/end-to-end)

在这两种情况下，每当使用 DH 时都需要进行一些验证：

#### 验证 DH 参数

客户端需要检查 **p = dh_prime** 是否是安全的 2048 位素数（意味着 **p** 和 **(p-1)/2** 都是素数，并且 2^2047 < p < 2^2048），以及 **g** 是否生成了一个素数阶 **(p-1)/2** 的循环子群，即 g 是 **mod p** 的一个二次余数。由于 **g** 始终等于 2、3、4、5、6 或 7，这可以通过使用二次互反律轻松完成，产生一个简单的关于 **p mod 4g** 的条件——即，对于 **g = 2 ，** **p mod 8 = 7**；**p mod 3 = 2**（**g = 3）**；**g = 4**没有额外条件；**p mod 5 = 1 或 4**（**g = 5）**；**p mod 24 = 19 或 23**（**g = 6）**；且**p mod 7 = 3、5 或 6**（对于**g = 7）**。**在客户端检查完 g **和 **p** 后，缓存结果是有意义的，以避免将来重复冗长的计算。

如果验证过程时间太长（旧移动设备就是这种情况），可以最初只运行15次 Miller-Rabin 迭代（在 Java 中使用参数 30）来验证**p**和**(p - 1)/2**的素数，错误概率不超过十亿分之一，并且稍后在后台进行更多迭代。

另一种优化方法是在客户端应用程序代码中嵌入一个包含一些已知的 “好” 对 **(g,p)**（或者只是已知的安全素数 **p**，因为在执行期间很容易验证 **g** 的条件）的小表格，这些在代码生成阶段已经检查过，以便完全避免在运行时进行此类验证。服务器很少更改这些值，因此通常需要将服务器的 dh_prime 的当前值放入这样的表中。例如，dh_prime 的当前值等于（以大端字节顺序）。

```
C7 1C AE B9 C6 B1 C9 04 8E 6C 52 2F 70 F1 3F 73 98 0D 40 23 8E 3E 21 C1 49 34 D0 37 56 3D 93 0F 48 19 8A 0A A7 C1 40 58 22 94 93 D2 25 30 F4 DB FA 33 6F 6E 0A C9 25 13 95 43 AE D4 4C CE 7C 37 20 FD 51 F6 94 58 70 5A C6 8C D4 FE 6B 6B 13 AB DC 97 46 51 29 69 32 84 54 F1 8F AF 8C 59 5F 64 24 77 FE 96 BB 2A 94 1D 5B CD 1D 4A C8 CC 49 88 07 08 FA 9B 37 8E 3C 4F 3A 90 60 BE E6 7C F9 A4 A4 A6 95 81 10 51 90 7E 16 27 53 B5 6B 0F 6B 41 0D BA 74 D8 A8 4B 2A 14 B3 14 4E 0E F1 28 47 54 FD 17 ED 95 0D 59 65 B4 B9 DD 46 58 2D B1 17 8D 16 9C 6B C4 65 B0 D6 FF 9C A3 92 8F EF 5B 9A E4 E4 18 FC 15 E8 3E BE A0 F8 7F A9 FF 5E ED 70 05 0D ED 28 49 F4 7B F9 59 D9 56 85 0C E9 29 85 1F 0D 81 15 F6 35 B1 05 EE 2E 4E 15 D0 4B 24 54 BF 6F 4F AD F0 34 B1 04 03 11 9C D8 E3 B9 2F CC 5B
```

#### g_a 和 g_b 验证

**除了对 Diffie-Hellman 素数 dh_prime** 和生成器 **g** 上的条件外，双方还需要检查 **g**、**g_a **和 **g_b **是否都大于 **1** 且小于 **dh_prime - 1**。我们建议检查 **g_a **和 **g_b** 是否位于 **2^{2048-64} **和 **dh_prime - 2^{2048-64}** 之间。

#### 在密钥生成期间检查 SHA1 哈希值 

当客户端在授权密钥生成协议的第 5 步接收到 `server_DH_params_ok` 应答并解密它，获得 `answer_with_hash` 时，它必须检查

```
answer_with_hash := SHA1(answer) + answer + (0-15 random bytes)
```

换句话说，`answer_with_hash` 的前 20 字节必须等于解密消息的剩余部分（不包括填充的随机字节）的 SHA1 值。

#### 检查 nonce、server_nonce 和 new_nonce 字段

当客户端在创建授权密钥期间接收和/或解密服务器消息，并且这些消息包含客户端从协议同一运行中之前获得的消息已知的一些 nonce 字段时，客户端要检查这些字段确实包含之前已知的值。

#### 使用安全伪随机数生成器来创建 DH 秘密参数 `a` 并 `b`

客户端必须使用密码学上安全的 PRNG 来生成 DH 密钥交换的秘密指数 `a` 或 `b`。[对于秘密聊天，客户端可能会在调用messages.getDhConfig](https://core.telegram.org/method/messages.getDhConfig) 时从服务器请求一些熵（随机字节），并将这些随机字节输入到其 PRNG 中（例如，如果使用 OpenSSL 库，则通过 `PRNG_seed`），但永远不要单独使用这些“随机”字节或用它们替换本地 PRNG 种子。应将从服务器接收到的字节混入本地 PRNG 种子中。

### MTProto 加密消息

[在发送、特别是接收加密的 MTProto 消息](https://core.telegram.org/mtproto/description)时需要进行一些重要的检查。

#### 检查 msg_key 的 SHA256 哈希值

`msg_key`不仅用于计算 AES 密钥和 IV 来解密接到的消息。解密后，客户端**必须**检查 `msg_key` 确实等于解密结果（包括最后的12...1024个填充字节）的 SHA256 哈希值，前面要加上从 `auth_key` 中取的32个字节，如[MTProto 2.0 描述](https://core.telegram.org/mtproto/description#defining-aes-key-and-initialization-vector)中所述。

如果在执行此检查之前遇到错误，客户端**必须**在返回任何结果之前进行 `msg_key` 检查。注意，对在 `msg_key` 检查之前遇到的任何错误的响应，**必须**与 `msg_key` 检查失败的响应相同。

#### 检查消息长度

客户端**必须**检查从解密消息中获得的消息或容器的长度（从其 `length` 字段计算得出）不超过明文的总大小，并且差值（即随机填充的长度）在12到1024字节的范围内。

长度应始终能被 4 整除且非负。客户端绝不允许访问包含明文消息的解密缓冲区末尾之外的数据。

#### 检查 session_id

客户端要检查解密消息中的 `session_id` 字段确实等于客户端创建的一个活动会话的 `session_id`。

#### 检查 msg_id

客户端必须检查客户端到服务器的消息中 `msg_id` 为偶数，服务器到客户端的消息中 `msg_id` 为奇数。

此外，必须存储从对方接收到的最后N条消息的标识符（msg_id），如果收到的消息的 msg_id 低于所有存储的值或等于任何存储的值，则该消息将被忽略。否则，将新消息的 msg_id 添加到集合中去，如果存储的 msg_id 值数量大于 N，则丢弃最旧的（即最低的）。

此外，属于未来超过 30 秒或过去超过 300 秒的 msg_id 值将被忽略（回想一下 `msg_id` 大于等于 unixtime * 2^32）。这对于服务器来说尤其重要。客户端也会发现这很有用（以防止重放攻击），但前提是它对自己的时间有信心（例如，如果它的时间已与服务器同步）。

某些客户端到服务器的服务消息，包含客户端发送到服务器的数据（例如，最近客户端查询的 `msg_id`），即使时间似乎“不正确”，也可能在客户端上被处理。更改 server_salt 的消息和关于客户端时间无效的通知尤其如此。请参阅[移动协议：服务消息](https://core.telegram.org/mtproto/service_messages)。

## 不匹配情况下的行为

如果上面列出的检查中的任何一项失败，客户端应完全丢弃从服务器获得的消息。我们还建议关闭并重新建立与服务器的TCP连接，然后重试操作或整个密钥生成协议。

不能使用来自错误消息中的任何信息。即使应用程序抛出异常并终止，这也比继续使用无效数据要好得多。

请注意，即使没有恶意篡改，正常工作期间也会偶尔出现无效消息。这是由于网络传输错误造成的。我们建议忽略无效消息，关闭TCP连接，然后创建新的TCP连接到服务器并重试原始查询。

>   与 MTProto 1.0 客户端相关的先前版本的安全建议可[在此处](https://core.telegram.org/mtproto/security_guidelines_v1)获取。